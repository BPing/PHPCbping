#功能介绍
###配置

* 系统配置
* 用户配置

###注册模式(缓存)

* [Registers](https://github.com/BPing/PHPCbping/tree/dev/PHPCbping/Registers)

* 相关配置

> *文件驱动配置 <br>
> DATA_CACHE_COMPRESS : 是否压缩数据再保存 <br>
> DATA_CACHE_CHECK : 是否进行数据安全校验  <br>
> FILE_CACHE_PATH :  缓存文件目录（相对于应用目录）<br>
> FILE_CACHE_NAME_PREFIX : 缓存文件名前缀 <br>

* 缓存驱动

  * 文件
  
  >  * 每一条数据对应一个文件(.php) <br>
  >  * 每一个键名对应唯一文件，键名相同则会覆盖前一个。<br>
  >  * 根据配置对数据压缩，添加校验码然后保存到文件中<br>
  >  * 根据键名提取相对应的文件数据，校验、解压然后返回<br>
  >  * 每一条数据可以设置缓存时间的<br>

  * apc
  
  >  配置使用请参考官方手册：http://www.php.net/apc
  
* 外观

    外观类拥有驱动类的实例，所以所有的操作最终都委托到相应的缓存驱动完成。
    
```php
/**
 * 应用程序注册类  Class AppRegister
 *
 *
 * @package Registers
 * @author cbping
 */
class AppRegistry
{
    /** @var AppRegistry */
    private static $_instance;

    /** 保存数据驱动 @var driver */
    private $_driver;


    private function __construct()
    {
    }

    /**
     * @return AppRegistry
     */
    public function getInstance($arg_type = '', $arg_options = array())
    {
        if (!isset(self::$_instance)) {
            self::$_instance = new self();
            self::$_instance->init($arg_type, $arg_options);
        }
        return self::$_instance;
    }

    /**
     * 初始化工作
     *
     */
    public function init($arg_type = '', $arg_options = array())
    {
        $this->_driver = Driver::getInstance($arg_type, $arg_options);
    }

    /**
     * 获取值
     *
     * @param $arg_key string
     * @return mixed
     */
    public function  get($arg_key)
    {
        return $this->_driver->get($arg_key);
    }

    /**
     * 设置值（注册）
     *
     * @param $arg_key string
     * @param $arg_value mixed
     * @param $arg_expire int 有效时间（S）
     * @return mixed
     */
    public function  set($arg_key, $arg_value, $arg_expire = null)
    {
        return $this->_driver->set($arg_key, $arg_value, $arg_expire);
    }

    /**
     * 清除注册表
     *
     * @return mixed
     */
    public function clear()
    {
        return $this->_driver->clear();

    }

    /**
     * 删除注册表
     *
     * @param $arg_key 需要删除的键名
     * @return mixed
     */
    public function delete($arg_key)
    {
        return $this->_driver->delete($arg_key);
    }

    /**
     * 更新注册表的值
     *
     * @param $arg_key 需要更新的键名
     * @param $arg_value 更新后的值
     * @param $arg_expire int 有效时间（S）
     * @return mixed
     */
    public function update($arg_key, $arg_value, $arg_expire = null)
    {
        return $this->_driver->update($arg_key, $arg_value, $arg_expire);
    }

    /**
     * 魔术方法__call
     *
     * @param $method
     * @param $args
     * @return mixed|void
     */
    public function __call($method, $args)
    {
        //调用缓存类型自己的方法
        if (method_exists($this->_driver, $method)) {
            return call_user_func_array(array($this->_driver, $method), $args);
        } else {
            //TODO:异常处理
            return;
        }
    }

    public function __get($name)
    {
        return $this->get($name);
    }

    public function __set($name, $value)
    {
        return $this->set($name, $value);
    }
}
```

###日志模块
* [Log](https://github.com/BPing/PHPCbping/tree/dev/PHPCbping/Utils)

* 日志级别

 >  **debug** <br>
 >  **warn**  <br>
 >  **info**  <br>
 >  **error** <br>

* 日志配置项
 > LOG_PATH : 日志文件目录 <br>
 > log.log :日志文件名字

* 日志格式
 > [2015/10/22 23:15:00][debug]:message

```php
if (!function_exists('log_message')) {
    /**
     * 日志记录
     *
     * 级别采用php库的全局变量  支持级别 LOG_WARNING LOG_ERR LOG_INFO LOG_DEBUG
     * 分别映射到日志句柄{@link LogI }对应方法：logWarn logError logInfo logDebug
     *
     * @param $level int 支持级别 LOG_WARNING LOG_ERR LOG_INFO LOG_DEBUG
     * @param $message
     * @param LogI $newLog null 对应核心的日志接口：LogI
     * @return old or null
     * @see LogI
     */
    function log_message($level, $message, $newLog = null)
    {
        static $_log;
        if ($newLog instanceof LogI) {
            $old = $_log;
            $_log = $newLog;
        }
        if (empty($_log))
            return;
        if ($level == LOG_ERR) {
            $_log->logError($message);
        }
        if ($level == LOG_WARNING) {
            $_log->logWarn($message);
        }
        if ($level == LOG_INFO) {
            $_log->logInfo($message);
        }
        if ($level == LOG_DEBUG) {
            $_log->logDebug($message);
        }
//        echo $message;
        return isset($old) ? $old : null;
    }
}
```

``` 
    //日志使用代码示例 
     log_message(LOG_INFO, "初始处理完毕", \Utils\UtilFactory::getLogHandle());
        
```

###自动加载类

*[class Loader](https://github.com/BPing/PHPCbping/blob/dev/PHPCbping/Loader.class.php)

* 配置

> `APP_AUTOLOAD_PATH` : 自动加载类目录。在此目录集合下寻找类文件<br>
> `CLASS_FILE_SUFFIX` : 类文件可能存在的后缀名<br>

* 策略

> 自动加载时自动忽略命名空间存在 <br>
> 遍历目录集合`APP_AUTOLOAD_PATH` 和 后缀名集合 `CLASS_FILE_SUFFIX`    组合，试探是否存在该类的文件，存在则引进`require_once($file)`,最终不存在则抛出异常 <br>

> **Note:** <br>
1、不能重复定义相同的类；<br>
2、类和类的文件存在唯一的映射关系，文件名=类名+后缀名`CLASS_FILE_SUFFIX` <br>

###控制器定位模块

* 配置
* 策略
* 规范

###上下文模块(Context)

* 配置
* 输入输出

###异常错误处理模块

* 配置
* 策略
  * 异常
  * 一般错误
  * 致命错误
* ... 
